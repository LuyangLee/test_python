## 心得

[TOC]



## ·参数

1、传递数据可以有**两种方式**，一种是通过**指针**（**形参**以*为标志传参，或者用a[]来表示地址），一种是**返回值**（返回数组，表或者容器）。

2、静态数组在传递的时候返回的是**一个地址**，所以函数用**<T>***来承接。





## ·编译

gcc编译的时候，在当前windows用mingw32-g++编译，使用

> mingw32-g++ -o 可执行文件名称  name.cpp
>
> mingw32-g++ -o 可执行文件名称 name.cpp -g(可以在vs中进入调试模式)
>
> vs在launch.json中对进行改变配置。![1527920896286](C:\Users\SOPHIA~1\AppData\Local\Temp\1527920896286.png)

执行的时候直接是运行exe文件即可。



## ·数组

+ **类型 数组名[常量表达式]**       如： int a[8];
+ **初始化**：
  + 全部元素赋值：int a[3] = {1,2,3}；
  + 部分元素赋值：int a[3] = {1};//其余默认为0
  + 计算间距：对于startIndex而言如果长度为length，那么最后一个元素的序号应为startIndex + length -1;
  + 恰恰相反，end - start + 1才是所得的元素的个数。
+ **字符数组**
  + char a[] = {'a', 'b', 'c','d'};     *==正确==*
  + char a[4] ;     a = {'a', 'b', 'c'};   ==*错误，不能用该语句直接赋值*==
  + char a[] = {"abcd"};   ==正确== 
  + 对于a[]而言，进行遍历的时候可以直接用下标遍历。
  + "acs,ew"   "acs /(换行)ew"  "acs"+","+"ew"
+ **二维数组**
  + 对于二维数组而言$m[m\_row][m\_colmn]$,计算数组的==某个元素==的位置，是$row*m\_column + column$一定要==注意不是==行和行数相乘。

## ·New关键字的使用

- **普通变量**

  - 1、 int *x = new int;       //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)
    2 、int *a = new int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址
    3 、char *b = new char[10]; //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址

- **二维数组**

  - int *p_data = new int[row * col];	//先建立一个一维的数组

    int (\*p)[col] = (int (\*)[col])p_data;	//再根据维度转化为一个二维的指针

- **对象**

  - 使用New实际上做了三件事：获得一块内存空间、调用构造函数、返回正确的指针。 
    - Object *name = new Object(); 

## ·Delete关键字的使用

- **两种情况**
   根据new的形式来delete：
   - 1、int *a = new int;	------->delete a;
     - 2、int *a = new int[10];    ------> delete[] a;



## ·类的说明

- 类的**数据成员**占对象的空间，而函数是在类外占空间的，在使用的时候使用this指针来区分不同对象。
- 对象的**引用**是Obeject&name = anotherObject，使用时表示给后面的对象起了一个**别名**。
- **类的存放**
  - 类的声明放在.h文件中
  - 类的成员函数定义放在.cpp中，否则就会重复被编译。

## ·模板

- 模板使用***template<typename/class EngName>***的格式建立；
- 模板定义：模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。模版可以分为两类，一个是函数模版，另外一个是类模版。 
- 函数模板
  - 函数模板直接将每个参数类型变为定义的EngName就好了，其余一模一样。
- 类模板
  - 类模板其实和函数模板差不多，只是类模板的成员属性的类型也可以用模板来表示。
  - 同时类的**函数在类型**返回前面要用$Objectname<EngName>$表示返回值。
  - **每一个**函数都要进行**前面**模板声明，

## ·sizeof

- sizeof用来测量一个类型所占的内存空间，当填入数组名时，当做数组类型来运算（经过一些处理）；当数组名称当做函数的参数传递时，数组名退化为同类型的指针。



## ·算法--->程序思维

- ==查找，遍历==等必然用到循环，使用下标寻找的大多数是for循环，使用比较的大多是是while循环；
- ==二重循环==：二重循环的内循环通常是一轮完整的比较或者是遇到终止条件，外循环通常是针对内循环的局部性拓宽成完全的整体性排列。
- 合并两个数组，当不借助第三个数组的时候，那么从后往前遍历一般优于从前往后遍历。
- 只有对==链表==才会使用指针移动操作，对于数组，使用下标是一件比较快的事情。
- 对于有一个以上的判断而言，通常约束其他变量可以保证只剩下该变量。



## ·链表注意事项


- 链表首先要判断头结点是不是为空，如果不是递归那要判断到最后一个结点，如果是的话那就判断到倒数第二个结点。



## ·C++表达式

- 左值指向内存的某个位置。
- 右值指的是存储在内存中某些地址的数值。 
- 所有的==浮点==运算都是以==双精度==进行的，。
- 在==赋值==运算中，赋值号两边量的数据类型不同时，赋值号==右边量的类型==将==转换为左边量==的类型。 
- a = NULL (正确)  NULL = a(错误)   a \== NULL(正确)  NULL \== a(错误)



## ·C++变量

- **静态变量**

  ​	存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，

  ​	如果作为 static 局部变量在==函数内定义==，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。 

## ·C++define和const

1. 类型和安全检查不同，define是替换不做检查，const要符合变量的规则，
2. 宏定义是预处理展开，const是运行时的时候展开
3. define定义域比较广，而const要符合变量的一般定义域
4. \#undef可以去除define，const一直存在。

**const**

- 欲阻止一个变量被改变，可使用const，在定义该const变量时，需先初始化，以后就没有机会改变他了；
- 对指针而言，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
- 在一个函数声明中，const可以修饰形参表明他是一个输入参数，在函数内部不可以改变其值；
- 对于类的成员函数，有时候必须指定其为const类型，表明其是一个常函数，不能修改类的成员变量；
- 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。



## ·存储类

- **auto**

  - **auto** 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 
  - auto f=3.14;      //double 
  - auto s("hello");  //const char* 
  - auto z = new auto(9); // int* 

- **static**

  -   static局部变量中文名叫静态局部变量。它与普通的局部变量比起来有如下几个区别：

  ​           1）位置：静态局部变量被编译器放在==全局存储区.data==（注意：不在.bss段内），所以它虽然是局部的，但是在程序的整个生命周期中存在。

  ​           2）访问权限：静态局部变量只能被其==作用域内的变量或函数==访问。也就是说虽然它会在程序的整个生命周期中存在，由于它是局部变量，它不能被其他的函数和源文件访问。

  ​           3）值：静态局部变量如果没有被用户初始化，则会被编译器自动赋值为0，以后每次调用静态局部变量的时候都==用上次调用后的值==。这个比较好理解，每次函数调用静态局部变量的时候都修改它然后离开，下次读的时候从全局存储区读出的静态局部变量就是上次修改后的值。

  - 当你的程序中有很多个源文件的时候，你肯定会让某个源文件只提供一些外界需要的接口，其他的函数可能是为了实现这些接口而编写，这些其他的函数你可能并不希望被外界（非本源文件）所看到，这时候就可以用static修饰这些“其他的函数”。所以static函数的==作用域是本源文件==，把它想象为面向对象中的private函数就可以了。
  - 1). 静态成员函数是先于类的对象而存在
  - 2). 可用类名直接调用（公有）
  - 3). 在静态成员函数中没有this指针，所以不能使用非静态成员